; ;
;   Variables globales compartidas por los drivers.
;	
; ;
#include <DEFINITIONS.inc>

TIMER0_PRECH	    EQU	    .18661
UART_BUFFER_SIZE    EQU	    .32
UART_BUFFER_ADDR    EQU	    0x100
    
STRING	UDATA	UART_BUFFER_ADDR
UART_BUFFER RES UART_BUFFER_SIZE
    
RES_VECT  CODE    0x00            ; processor reset vector
    GOTO    START                   ; go to beginning of program
H_ISR	CODE	0x08
    GOTO    HIGH_ISR
L_ISR	CODE	0x18
    GOTO    LOW_ISR
; TODO ADD INTERRUPTS HERE IF USED
MAIN_PROG CODE                      ; let linker place main program
HIGH_ISR:
    ;
    ; CARGAR	WREG
    ;		STATUS
    ;		BSR
    ; EN STACK {
    PUSH
    MOVWF	TOSL,0	    ;TOSL = WREG
    MOVF	STATUS,W,0  ;
    MOVWF	TOSH,0	    ;TOSH = STATUS
    MOVF	BSR,W,0	    ;
    MOVWF	TOSU,0	    ;TOSU = BSR
    ;	}
    BTFSC	INTCON,TMR0IF,0	; VERIFICAR SI TMR0IF ESTA ACTIVA
    BRA		TMR0_ISR
    BTFSC	PIR1,RCIF,0	; VERIFICAR SI RCIF ESTA ACTIVO
    BRA		UART_RX_ISR
    BTFSC	PIR1,TXIF,0	; VERIFICAR SI TXIF ESTA ACTIVO
    BRA		UART_TX_ISR
    BRA		HISR_OUT	; SALIR DE LA INTERRUPCION RECUPERANDO DATOS DE LA PILA
TMR0_ISR:
    BANKSEL	TIMER0_PRECHARGE
    MOVF	TIMER0_PRECHARGE+.1,W,1
    MOVWF	TMR0H,0
    MOVF	TIMER0_PRECHARGE,W,1
    MOVWF	TMR0L,0
    BTG		LATA,RA4,0
    BCF		INTCON,TMR0IF,0		; LIMPIAR POSIBLES INTERRUPCIONES
    BANKSEL UART_BUFFER			; CARGAR PUNTEROS Y CONTADOR
    MOVLW   (UART_BUFFER_ADDR & 0xFF)
    MOVWF   0x00,0
    MOVLW   (UART_BUFFER_ADDR>>.8) & 0xFF
    MOVWF   0x01,0
    MOVLW   UART_BUFFER_SIZE+.1
    MOVWF   0x02,0
    CALL	UART_TRANSMIT		; SOLICITAR TRANSMISION
    BRA		HISR_OUT	; SALIR DE LA INTERRUPCION RECUPERANDO DATOS DE LA PILA
UART_TX_ISR:
    BANKSEL	UART_TX
    MOVF	UART_TX,W,1	;
    MOVWF	FSR2L,0		;   CARGAR APUNTADOR
    MOVF	UART_TX+.1,W,1	;   DE TRANSMISION
    MOVWF	FSR2H,0		;
    DECFSZ	UART_TX_COUNTER,1	    ; Decrementar el contador y saltar si cero
    BRA		UART_TX_ISR_
    MOVLW	'\n'
    MOVWF	TXREG,0
    BCF		PIE1,TXIE,0	    ; El contador esta vacio, terminar Transmision
    CLRF	UART_TX_STATUS,1
    BRA		HISR_OUT	    ; SALIR DE LA INTERRUPCION RECUPERANDO DATOS DE LA PILA
UART_TX_ISR_:
    MOVF	POSTINC2,W	    ; Cargar del apuntador y enviar
    MOVWF	TXREG,0		    ;
    MOVF	FSR2L,W,0
    MOVWF	UART_TX,1	    ;
    MOVF	FSR2H,W,0	    ;	ALMACENAR APUNTADOR
    MOVWF	UART_TX+.1,1	    ;
    BRA		HISR_OUT	; SALIR DE LA INTERRUPCION RECUPERANDO DATOS DE LA PILA
UART_RX_ISR:
    MOVF	RCREG,W,0
    MOVWF	TXREG,0
    BRA		HISR_OUT	; SALIR DE LA INTERRUPCION RECUPERANDO DATOS DE LA PILA
HISR_OUT:
    ; SACAR VARIABLES DEL STACK {
    MOVF	TOSU,W,0    ;BSR    = TOSU
    MOVWF	BSR,0
    MOVF	TOSH,W,0    ;STATUS = TOSH
    MOVWF	STATUS
    MOVF	TOSL,W,0    ;WREG   = TOSL
    POP
    ;	}
    RETFIE
LOW_ISR:
    NOP
    RETFIE
START:
    CALL    POR_SYS
;    BZ	  ERROR_SYS;SI NO ES CERO SALTAR
    CALL    SYSTEM_INIT
    CALL    TIMER0_INIT
    CALL    UART_INIT
    CALL    UART_START
    ;	CONFIGURE TIMER PRECHARGE {
    MOVLW   (TIMER0_PRECH >> 8)
    MOVWF   0x01
    MOVLW   (TIMER0_PRECH & 0xFF)
    MOVWF   0x00
    CALL    TIMER0_WR
    ;	CONFIGURE TIMER PRECHARGE }
    ;	CONFIGURAR BUFFER UART TX {
    MOVLW   (UART_BUFFER_ADDR & 0xFF)
    MOVWF   0x00,0
    MOVLW   (UART_BUFFER_ADDR>>.8) & 0xFF
    MOVWF   0x01,0
    MOVLW   UART_BUFFER_SIZE+.1
    MOVWF   0x02,0
    ;	CONFIGURAR BUFFER UART TX }
    ;	ESCRIBIR DATOS EN EL BUFFER
    BANKSEL UART_BUFFER
    MOVLW   'H'
    MOVWF   UART_BUFFER,1
    MOVLW   'e'
    MOVWF   UART_BUFFER+.1,1
    MOVLW   'l'
    MOVWF   UART_BUFFER+.2,1
    MOVLW   'l'
    MOVWF   UART_BUFFER+.3,1
    MOVLW   'o'
    MOVWF   UART_BUFFER+.4,1
    MOVLW   ' '
    MOVWF   UART_BUFFER+.5,1
    MOVLW   'w'
    MOVWF   UART_BUFFER+.6,1
    MOVLW   'o'
    MOVWF   UART_BUFFER+.7,1
    MOVLW   'r'
    MOVWF   UART_BUFFER+.8,1
    MOVLW   'l'
    MOVWF   UART_BUFFER+.9,1
    MOVLW   'd'
    MOVWF   UART_BUFFER+.10,1
    MOVLW   ' '
    MOVWF   UART_BUFFER+.11,1
    MOVLW   '0'
    MOVWF   UART_BUFFER+.12,1
    MOVLW   '1'
    MOVWF   UART_BUFFER+.13,1
    MOVLW   '2'
    MOVWF   UART_BUFFER+.14,1
    MOVLW   '3'
    MOVWF   UART_BUFFER+.15,1
    MOVLW   '4'
    MOVWF   UART_BUFFER+.16,1
    MOVLW   '5'
    MOVWF   UART_BUFFER+.17,1
    MOVLW   '6'
    MOVWF   UART_BUFFER+.18,1
    MOVLW   '7'
    MOVWF   UART_BUFFER+.19,1
    MOVLW   '8'
    MOVWF   UART_BUFFER+.20,1
    MOVLW   '9'
    MOVWF   UART_BUFFER+.21,1
    MOVLW   'A'
    MOVWF   UART_BUFFER+.22,1
    MOVLW   'B'
    MOVWF   UART_BUFFER+.23,1
    MOVLW   'C'
    MOVWF   UART_BUFFER+.24,1
    MOVLW   'D'
    MOVWF   UART_BUFFER+.25,1
    MOVLW   'E'
    MOVWF   UART_BUFFER+.26,1
    MOVLW   'F'
    MOVWF   UART_BUFFER+.27,1
    MOVLW   '0'
    MOVWF   UART_BUFFER+.28,1
    MOVLW   '@'
    MOVWF   UART_BUFFER+.29,1
    MOVLW   '#'
    MOVWF   UART_BUFFER+.30,1
    MOVLW   '&'
    MOVWF   UART_BUFFER+.31,1
    ;	SOLICITAR TRANSMISION
	;   DONT REALLY CARE, JUST AN ECHO TEST
	;    CLRF    0x00,0
	;    CLRF    0x01,0
	;    CLRF    0x02,0
    CALL    UART_RECEIVE
;   CONFIGURAR PUERTO A {  
    CLRF 	PORTA
    CLRF 	LATA
    MOVLW	0Fh
    MOVWF	ADCON1
    MOVLW	07h
    MOVWF	CMCON
    CLRF	TRISA;Configurar PORTA como salida
;   CONFIGURAR PUERTO A }
    CALL    TIMER0_START
    GOTO    $
    END