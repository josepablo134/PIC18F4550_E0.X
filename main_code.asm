; ;
;   Variables globales compartidas por los drivers.
;	
; ;
#include <DEFINITIONS.inc>

UART_BUFFER_SIZE    EQU	    .32
UART_BUFFER_ADDR    EQU	    0x100
    
STRING	UDATA	UART_BUFFER_ADDR
UART_BUFFER RES UART_BUFFER_SIZE
    
RES_VECT  CODE    0x00            ; processor reset vector
    GOTO    START                   ; go to beginning of program
H_ISR	CODE	0x08
    GOTO    HIGH_ISR
L_ISR	CODE	0x18
    GOTO    LOW_ISR
; TODO ADD INTERRUPTS HERE IF USED
MAIN_PROG CODE                      ; let linker place main program
HIGH_ISR:
    ;
    ; CARGAR	WREG
    ;		STATUS
    ;		BSR
    ; EN STACK {
    PUSH
    MOVWF	TOSL,0	    ;TOSL = WREG
    MOVF	STATUS,W,0  ;
    MOVWF	TOSH,0	    ;TOSH = STATUS
    MOVF	BSR,W,0	    ;
    MOVWF	TOSU,0	    ;TOSU = BSR
    ;	}
    BTFSC	INTCON,TMR0IF,0	; VERIFICAR SI TMR0IF ESTA ACTIVA
    BRA		TMR0_ISR
    BTFSC	PIR1,RCIF,0	; VERIFICAR SI RCIF ESTA ACTIVO
    BRA		UART_RX_ISR
    BTFSC	PIR1,TXIF,0	; VERIFICAR SI TXIF ESTA ACTIVO
    BRA		UART_TX_ISR
    BRA		HISR_OUT	; SALIR DE LA INTERRUPCION RECUPERANDO DATOS DE LA PILA
TMR0_ISR:
    BCF		INTCON,TMR0IF,0;LIMPIAR POSIBLES INTERRUPCIONES
    MOVLB	0x00; RECARGAR BSR ANTES DE REGRESAR
    BTG		LATA,RA4,0
    MOVF	TIMER0_PRECHARGE,W,1
    MOVWF	TMR0L,0
    MOVF	TIMER0_PRECHARGE+1,W,1
    MOVWF	TMR0H,0
    MOVLW	UART_BUFFER_SIZE+1  ; Pre cargar
    MOVWF	UART_COUNTER,1	    ; el contador UART
    ;	CARGAR EL APUNTADOR
    MOVF	UART_PTRL,W,1
    MOVWF	FSR2L,0
    MOVF	UART_PTRL+.1,W,1
    MOVWF	FSR2H,0
    ;	ACTIVAR INTERRUPCION DE TRANSMISION
    BSF		PIE1,TXIE,0
    BRA		HISR_OUT	; SALIR DE LA INTERRUPCION RECUPERANDO DATOS DE LA PILA
UART_TX_ISR:
    MOVLB	0x00		    ; REGRESAR EL BSR antes del RETFIE
    DECFSZ	UART_COUNTER,1	    ; Decrementar el contador y saltar si cero
    BRA		UART_TX_ISR_
    MOVLW	'\n'
    MOVWF	TXREG,0
    BCF		PIE1,TXIE,0	    ; El contador esta vacio, terminar Transmision
    BRA		HISR_OUT	; SALIR DE LA INTERRUPCION RECUPERANDO DATOS DE LA PILA
UART_TX_ISR_:
    MOVF	POSTINC2,W	    ; Cargar del apuntador y enviar
    MOVWF	TXREG,0		    ;
    BRA		HISR_OUT	; SALIR DE LA INTERRUPCION RECUPERANDO DATOS DE LA PILA
UART_RX_ISR:
    MOVF	RCREG,W,0
    MOVWF	TXREG,0
    BRA		HISR_OUT	; SALIR DE LA INTERRUPCION RECUPERANDO DATOS DE LA PILA
HISR_OUT:
    ; SACAR VARIABLES DEL STACK {
    MOVF	TOSU,W,0    ;BSR    = TOSU
    MOVWF	BSR,0
    MOVF	TOSH,W,0    ;STATUS = TOSH
    MOVWF	STATUS
    MOVF	TOSL,W,0    ;WREG   = TOSL
    POP
    ;	}
    RETFIE
LOW_ISR:
    NOP
    RETFIE
START:
    CALL    POR_SYS
;    BZ	  ERROR_SYS;SI NO ES CERO SALTAR
    CALL    SYSTEM_INIT
    CALL    TIMER0_INIT
    CALL    UART_INIT
;   CARGAR DATO AL UART {
    MOVLW	(UART_BUFFER_ADDR & 0xFF)	;
    MOVWF	0x00,0  ; CARGAR EL PUNTERO AL UART
    MOVLW	(UART_BUFFER_ADDR>>.8) & 0xFF	;
    MOVWF	0x01,0  ;
    CALL	UART_MOV
;   CARGAR DATO AL UART }
;   CONFIGURAR PUERTO A {  
    CLRF 	PORTA
    CLRF 	LATA
    MOVLW	0Fh
    MOVWF	ADCON1
    MOVLW	07h
    MOVWF	CMCON
    CLRF	TRISA;Configurar PORTA como salida
;   CONFIGURAR PUERTO A }
    ; Comenzar el servicio UART
    MOVLB	0x01
    MOVLW	'0'
    MOVWF	UART_BUFFER,1
    MOVLW	'1'
    MOVWF	UART_BUFFER+.1,1
    MOVLW	'2'
    MOVWF	UART_BUFFER+.2,1
    MOVLW	'3'
    MOVWF	UART_BUFFER+.3,1
    MOVLW	'4'
    MOVWF	UART_BUFFER+.4,1
    MOVLW	'5'
    MOVWF	UART_BUFFER+.5,1
    MOVLW	'6'
    MOVWF	UART_BUFFER+.6,1
    MOVLW	'7'
    MOVWF	UART_BUFFER+.7,1
    MOVLW	'8'
    MOVWF	UART_BUFFER+.8,1
    MOVLW	'9'
    MOVWF	UART_BUFFER+.9,1
    MOVLW	'A'
    MOVWF	UART_BUFFER+.10,1
    MOVLW	'B'
    MOVWF	UART_BUFFER+.11,1
    MOVLW	'C'
    MOVWF	UART_BUFFER+.12,1
    MOVLW	'D'
    MOVWF	UART_BUFFER+.13,1
    MOVLW	'E'
    MOVWF	UART_BUFFER+.14,1
    MOVLW	'F'
    MOVWF	UART_BUFFER+.15,1
    MOVLW	' '
    MOVWF	UART_BUFFER+.16,1
    MOVLW	'H'
    MOVWF	UART_BUFFER+.17,1
    MOVLW	'e'
    MOVWF	UART_BUFFER+.18,1
    MOVLW	'l'
    MOVWF	UART_BUFFER+.19,1
    MOVLW	'l'
    MOVWF	UART_BUFFER+.20,1
    MOVLW	'o'
    MOVWF	UART_BUFFER+.21,1
    MOVLW	' '
    MOVWF	UART_BUFFER+.22,1
    MOVLW	'w'
    MOVWF	UART_BUFFER+.23,1
    MOVLW	'o'
    MOVWF	UART_BUFFER+.24,1
    MOVLW	'r'
    MOVWF	UART_BUFFER+.25,1
    MOVLW	'l'
    MOVWF	UART_BUFFER+.26,1
    MOVLW	'd'
    MOVWF	UART_BUFFER+.27,1
    MOVLW	'#'
    MOVWF	UART_BUFFER+.28,1
    MOVLW	'#'
    MOVWF	UART_BUFFER+.29,1
    MOVLW	'#'
    MOVWF	UART_BUFFER+.30,1
    MOVLW	'#'
    MOVWF	UART_BUFFER+.31,1
    CALL	UART_START
    CALL	TIMER0_START
    
;   CONFIGURAR AUTOFANTASTICO EN PUERTO B Y PUERTO D
    CBLOCK	    0x00
	DELAY_R0
	DELAY_R1
	COUNTER
    ENDC
DELAY_R0_PRECHARGE	EQU 0x00
DELAY_R1_PRECHARGE	EQU 0x00
COUNTER_PRECHARGE	EQU 0x08

    CLRF	PORTB,0
    CLRF	PORTD,0
    MOVLW	0x0E
    MOVWF	ADCON1,0
    CLRF	TRISB,0;H
    CLRF	TRISD,0;L
    
    BSF		LATB,RB0,0;Cargar el bit que se rotara
LOOP:
PORTB_LEFT_ROTATION:
    ;CALL    DELAY
    RLCF    LATB,F,0
    BC	    PORTD_LEFT_ROTATION
    goto    PORTB_LEFT_ROTATION
PORTD_LEFT_ROTATION:
    ;CALL    DELAY
    RLCF    LATD,F,0
    BC	    PORTD_RIGHT_ROTATION
    goto    PORTD_LEFT_ROTATION
PORTD_RIGHT_ROTATION:
    ;CALL    DELAY
    RRCF    LATD,F,0
    BC	    PORTB_RIGHT_ROTATION
    goto    PORTD_RIGHT_ROTATION
PORTB_RIGHT_ROTATION:
    ;CALL    DELAY
    RRCF    LATB,F,0
    BC	    LOOP
    goto    PORTB_RIGHT_ROTATION
DELAY:
    MOVLW   DELAY_R0_PRECHARGE
    MOVWF   DELAY_R0
    MOVLW   DELAY_R1_PRECHARGE
    MOVWF   DELAY_R1
DELAY_LOOP_0:
    DECFSZ  DELAY_R0
    BRA	    DELAY_LOOP_0
    DECFSZ  DELAY_R1
    BRA	    DELAY_LOOP_0
    RETURN
    END